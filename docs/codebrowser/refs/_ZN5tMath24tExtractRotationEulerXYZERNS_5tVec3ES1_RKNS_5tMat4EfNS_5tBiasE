<dec f='Modules/Math/Inc/Math/tLinearAlgebra.h' l='738' type='bool tMath::tExtractRotationEulerXYZ(tMath::tVec3 &amp; sol1, tMath::tVec3 &amp; sol2, const tMath::tMat4 &amp; rot, float gimbalZValue = 0.F, tMath::tBias  = tBias::Low)'/>
<doc f='Modules/Math/Inc/Math/tLinearAlgebra.h' l='711'>// This function extracts Euler angles from a rotation matrix. It assumes a particular order of rotations were applied.
// tExtractRotationEulerXYZ assumes an X, Y, Z order meaning the rotation matrix is RzRyRx. The other orders are not yet
// implemented.
//
// tExtractAffineEulerXYZ can extract rotations for affine transformations that do NOT include shear because the basis
// vectors aren&apos;t orthogonal. i.e. tExtractAffineEulerXYZ can handle non-uniform scale -- affine transforms preserve
// parallel lines and include Euclidean rotation/translation, non-uniform scale, and shear (which we are excluding).
//
// If you know the matrix is orthonormal (columns are orthogonal AND of unit length), use the Euclidian version:
// tExtractRotationEulerXYZ). It will be faster.
//
// Any particular orientation can be achieved by at least 2 sets of Euler rotations, so there are 2 sets of Euler angles
// returned. When the middle rotation (eulerY) satisfies Cos(eulerY) = 0 (the middle one is Y for the XYZ order, which
// we will now assume for the rest of this comment) there are an infinite number of solutions. This is called gimbal
// lock.
//
// In gimbal lock you usually want to choose one of the infinity of solutions. In particular the eulerZ angle may be
// anything, eulerY will be +- Pi/2 (cos == 0), and eulerX depends on your choice of eulerZ. This is what gimbalZValue
// is for, it allows EulerX to be calculated for you -- it is your &apos;choice&apos; of the Z rotation when in gimbal lock. Note
// that both sol1 and sol2 are equal when in gimbal lock. They both represent the chosen solution. IF you want to know
// what ALL solutions are, just leave gimbalZValue at zero. Choose any value for EulerZ (myZ). If EulerY &gt; 0, then
// EulerZ = EulerX + myZ. If EulerY &lt; 0, then EulerZ = EulerX - myZ.
//
// All returned angles are in [(-Pi, Pi)]. See comment by tIntervalBias for a description of my bias notation. This
// function Returns true if in gimbal lock or if it&apos;s close to gimbal lock as determined by an internal epsilon on
// Cos(eulerY). The extraction algorithm is based on this paper:
// http://staff.city.ac.uk/~sbbh653/publications/euler.pdf by Gregory G. Slabaugh. That&apos;s it. Simple, right?</doc>
<use f='Modules/Math/Inc/Math/tMatrix4.h' l='124' u='c' c='_ZNK5tMath8tMatrix423ExtractRotationEulerXYZERNS_5tVec3ES2_fNS_5tBiasE'/>
<def f='Modules/Math/Src/tLinearAlgebra.cpp' l='941' ll='981' type='bool tMath::tExtractRotationEulerXYZ(tMath::tVec3 &amp; sol1, tMath::tVec3 &amp; sol2, const tMath::tMat4 &amp; rot, float gimbalZ = 0.F, tMath::tBias bias = tBias::Low)'/>
<use f='Modules/Math/Src/tLinearAlgebra.cpp' l='990' u='c' c='_ZN5tMath22tExtractAffineEulerXYZERNS_5tVec3ES1_RKNS_5tMat4EfNS_5tBiasE'/>
