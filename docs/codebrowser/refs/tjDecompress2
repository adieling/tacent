<dec f='Modules/Image/Contrib/TurboJpeg/turbojpeg.h' l='1216' type='int tjDecompress2(tjhandle handle, const unsigned char * jpegBuf, unsigned long jpegSize, unsigned char * dstBuf, int width, int pitch, int height, int pixelFormat, int flags)'/>
<use f='Modules/Image/Src/tImageJPG.cpp' l='103' u='c' c='_ZN6tImage9tImageJPG4LoadEPKhiRKNS0_10LoadParamsE'/>
<doc f='Modules/Image/Contrib/TurboJpeg/turbojpeg.h' l='1166'>/**
 * Decompress a JPEG image to an RGB, grayscale, or CMYK image.
 *
 * @param handle a handle to a TurboJPEG decompressor or transformer instance
 *
 * @param jpegBuf pointer to a buffer containing the JPEG image to decompress
 *
 * @param jpegSize size of the JPEG image (in bytes)
 *
 * @param dstBuf pointer to an image buffer that will receive the decompressed
 * image.  This buffer should normally be &lt;tt&gt;pitch * scaledHeight&lt;/tt&gt; bytes
 * in size, where &lt;tt&gt;scaledHeight&lt;/tt&gt; can be determined by calling
 * #TJSCALED() with the JPEG image height and one of the scaling factors
 * returned by #tjGetScalingFactors().  The &lt;tt&gt;dstBuf&lt;/tt&gt; pointer may also be
 * used to decompress into a specific region of a larger buffer.
 *
 * @param width desired width (in pixels) of the destination image.  If this is
 * different than the width of the JPEG image being decompressed, then
 * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 * possible image that will fit within the desired width.  If &lt;tt&gt;width&lt;/tt&gt; is
 * set to 0, then only the height will be considered when determining the
 * scaled image size.
 *
 * @param pitch bytes per line in the destination image.  Normally, this is
 * &lt;tt&gt;scaledWidth * #tjPixelSize[pixelFormat]&lt;/tt&gt; if the decompressed image
 * is unpadded, else &lt;tt&gt;#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])&lt;/tt&gt;
 * if each line of the decompressed image is padded to the nearest 32-bit
 * boundary, as is the case for Windows bitmaps.  (NOTE: &lt;tt&gt;scaledWidth&lt;/tt&gt;
 * can be determined by calling #TJSCALED() with the JPEG image width and one
 * of the scaling factors returned by #tjGetScalingFactors().)  You can also be
 * clever and use the pitch parameter to skip lines, etc.  Setting this
 * parameter to 0 is the equivalent of setting it to
 * &lt;tt&gt;scaledWidth * #tjPixelSize[pixelFormat]&lt;/tt&gt;.
 *
 * @param height desired height (in pixels) of the destination image.  If this
 * is different than the height of the JPEG image being decompressed, then
 * TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 * possible image that will fit within the desired height.  If &lt;tt&gt;height&lt;/tt&gt;
 * is set to 0, then only the width will be considered when determining the
 * scaled image size.
 *
 * @param pixelFormat pixel format of the destination image (see @ref
 * TJPF &quot;Pixel formats&quot;.)
 *
 * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
 * &quot;flags&quot;
 *
 * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
 * and #tjGetErrorCode().)
 */</doc>
