<dec f='Modules/Image/Inc/Image/tQuantize.h' l='158' type='bool tImage::tQuantizeWu::QuantizeImage(int numColours, int width, int height, const tPixel3b * pixels, tColour3b * destPalette, uint8 * destIndices, bool checkExact = true)'/>
<doc f='Modules/Image/Inc/Image/tQuantize.h' l='151'>// If checkExact is true it will inspect all supplied pixels in case there are &lt;= numColours of them. If that is
	// true then the image is exactly representable given the palette size and the quantize is not needed. The operation
	// to gather unique pixel colours is a little slow, so you are given the ability to turn this off.
	//
	// destPalette should have space for numColours colours,
	// destIndices should have space for width*height indices.
	// The second variant is same as first but accepts RGBA pixels ignoring alpha.</doc>
<use f='Modules/Image/Src/tPaletteImage.cpp' l='152' u='c' c='_ZN6tImage13tPaletteImage3SetENS_12tPixelFormatEiiPK9tColour3bNS_9tQuantize6MethodE'/>
<def f='Modules/Image/Src/tQuantizeWu.cpp' l='532' ll='550' type='bool tImage::tQuantizeWu::QuantizeImage(int numColours, int width, int height, const tPixel3b * pixels, tColour3b * destPalette, uint8 * destIndices, bool checkExact = true)'/>
<use f='Modules/Image/Src/tQuantizeWu.cpp' l='566' u='c' c='_ZN6tImage11tQuantizeWu13QuantizeImageEiiiPK9tColour4bP9tColour3bPhb'/>
<doc f='Modules/Image/Src/tQuantizeWu.cpp' l='527'>//
// The functions below make up the external interface.
//</doc>
