<dec f='Modules/Image/Contrib/TurboJpeg/turbojpeg.h' l='1380' type='int tjDecodeYUV(tjhandle handle, const unsigned char * srcBuf, int pad, int subsamp, unsigned char * dstBuf, int width, int pitch, int height, int pixelFormat, int flags)'/>
<doc f='Modules/Image/Contrib/TurboJpeg/turbojpeg.h' l='1332'>/**
 * Decode a YUV planar image into an RGB or grayscale image.  This function
 * uses the accelerated color conversion routines in the underlying
 * codec but does not execute any of the other steps in the JPEG decompression
 * process.
 *
 * @param handle a handle to a TurboJPEG decompressor or transformer instance
 *
 * @param srcBuf pointer to an image buffer containing a YUV planar image to be
 * decoded.  The size of this buffer should match the value returned by
 * #tjBufSizeYUV2() for the given image width, height, padding, and level of
 * chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
 * stored sequentially in the source buffer (refer to @ref YUVnotes
 * &quot;YUV Image Format Notes&quot;.)
 *
 * @param pad Use this parameter to specify that the width of each line in each
 * plane of the YUV source image is padded to the nearest multiple of this
 * number of bytes (must be a power of 2.)
 *
 * @param subsamp the level of chrominance subsampling used in the YUV source
 * image (see @ref TJSAMP &quot;Chrominance subsampling options&quot;.)
 *
 * @param dstBuf pointer to an image buffer that will receive the decoded
 * image.  This buffer should normally be &lt;tt&gt;pitch * height&lt;/tt&gt; bytes in
 * size, but the &lt;tt&gt;dstBuf&lt;/tt&gt; pointer can also be used to decode into a
 * specific region of a larger buffer.
 *
 * @param width width (in pixels) of the source and destination images
 *
 * @param pitch bytes per line in the destination image.  Normally, this should
 * be &lt;tt&gt;width * #tjPixelSize[pixelFormat]&lt;/tt&gt; if the destination image is
 * unpadded, or &lt;tt&gt;#TJPAD(width * #tjPixelSize[pixelFormat])&lt;/tt&gt; if each line
 * of the destination image should be padded to the nearest 32-bit boundary, as
 * is the case for Windows bitmaps.  You can also be clever and use the pitch
 * parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
 * of setting it to &lt;tt&gt;width * #tjPixelSize[pixelFormat]&lt;/tt&gt;.
 *
 * @param height height (in pixels) of the source and destination images
 *
 * @param pixelFormat pixel format of the destination image (see @ref TJPF
 * &quot;Pixel formats&quot;.)
 *
 * @param flags the bitwise OR of one or more of the @ref TJFLAG_ACCURATEDCT
 * &quot;flags&quot;
 *
 * @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr2()
 * and #tjGetErrorCode().)
 */</doc>
