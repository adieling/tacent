// tQuantizeFixed.cpp
//
// This module implements quantization of an image based on a fixed palette of colours as well as a function to perform
// an exact palettization if the number of unique pixel colours is less-than or equal to the number of colours available
// to the palette.
//
// Copyright (c) 2022, 2023 Tristan Grimmer.
// Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby
// granted, provided that the above copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
// AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.

#include <Math/tColour.h>
#include <Foundation/tMap.h>
#include <System/tPrint.h>
#include <System/tFile.h>
#include "Image/tQuantize.h"
// #define QUANTIZE_GENERATE_FIXED_PALETTES
namespace tImage {


namespace tQuantizeFixed
{
	int FindIndexOfClosestColour_Redmean(const tColour3i* searchSpace, int searchSize, const tColour3i& colour);

	#ifdef QUANTIZE_GENERATE_FIXED_PALETTES
	// This is the function used to generate the power of 2 palettes (2, 4, 8, 16, 32, 64, 128, and 256 colour).
	// It is ifdeffed out and ony for reference as it's output is just a bunch of tables that are generated once and
	// included as static tabled in this source file.
	void GenerateFixedPalettes(const tString& filename);
	void GenerateFixedPalette(tFileHandle, int bitsR, int bitsG, int bitsB);
	#endif
}


#ifdef QUANTIZE_GENERATE_FIXED_PALETTES
void tQuantizeFixed::GenerateFixedPalettes(const tString& filename)
{
	tFileHandle file = tSystem::tOpenFile(filename, "wt");

	// Note favouring of green, then red, then blue.
	GenerateFixedPalette(file, 3, 3, 2);		// 8 bits.
	GenerateFixedPalette(file, 2, 3, 2);		// 7 bits.
	GenerateFixedPalette(file, 2, 2, 2);		// 6 bits.
	GenerateFixedPalette(file, 2, 2, 1);		// 5 bits.
	GenerateFixedPalette(file, 1, 2, 1);		// 4 bits.
	GenerateFixedPalette(file, 1, 1, 1);		// 3 bits.
	GenerateFixedPalette(file, 1, 1, 0);		// 2 bits.
	GenerateFixedPalette(file, 0, 1, 0);		// 1 bits.

	tSystem::tCloseFile(file);
}


void tQuantizeFixed::GenerateFixedPalette(tFileHandle file, int bitsR, int bitsG, int bitsB)
{
	int numR = tMath::tPow2(bitsR);
	int numG = tMath::tPow2(bitsG);
	int numB = tMath::tPow2(bitsB);
	int numColours = numR * numG * numB;

	tfPrintf(file, "// Generated fixed %d colour palette.\n", numColours);
	tfPrintf(file, "namespace tQuantizeFixed { tColour3i Palette%d[] =\n", numColours);
	tfPrintf(file, "{\n");

	int entriesPerRow = tMath::tMin(numColours, 8);
	int idx = 0;

	// Order is important. Favour green, then red, then blue. 
	for (int bi = 0; bi < numB; bi++)
	{
		for (int ri = 0; ri < numR; ri++)
		{
			for (int gi = 0; gi < numG; gi++)
			{
				int r = (numR == 1) ? 0 : (255 * ri) / (numR-1);
				int g = (numG == 1) ? 0 : (255 * gi) / (numG-1);
				int b = (numB == 1) ? 0 : (255 * bi) / (numB-1);

				if (!((idx) % entriesPerRow))
					tfPrintf(file, "\t");
				else
					tfPrintf(file, " ");

				if (((numColours == 4) && (idx == 3)) || ((numColours == 2) && (idx == 1)))
					r = g = b = 0xFF;

				tfPrintf(file, "{ 0x%02X, 0x%02X, 0x%02X }%s", r, g, b, (idx == numColours-1) ? "" : ",");
				if (!((idx+1) % entriesPerRow))
					tfPrintf(file, "\n");
				idx++;
			}
		}
	}
	tfPrintf(file, "}; tStaticAssert(tNumElements(tQuantizeFixed::Palette%d) == %d); }\n", numColours, numColours);
	tfPrintf(file, "\n");
}
#endif


// Generated fixed 256 colour palette.
namespace tQuantizeFixed { tColour3i Palette256[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0x24, 0x00 }, { 0x00, 0x48, 0x00 }, { 0x00, 0x6D, 0x00 }, { 0x00, 0x91, 0x00 }, { 0x00, 0xB6, 0x00 }, { 0x00, 0xDA, 0x00 }, { 0x00, 0xFF, 0x00 },
	{ 0x24, 0x00, 0x00 }, { 0x24, 0x24, 0x00 }, { 0x24, 0x48, 0x00 }, { 0x24, 0x6D, 0x00 }, { 0x24, 0x91, 0x00 }, { 0x24, 0xB6, 0x00 }, { 0x24, 0xDA, 0x00 }, { 0x24, 0xFF, 0x00 },
	{ 0x48, 0x00, 0x00 }, { 0x48, 0x24, 0x00 }, { 0x48, 0x48, 0x00 }, { 0x48, 0x6D, 0x00 }, { 0x48, 0x91, 0x00 }, { 0x48, 0xB6, 0x00 }, { 0x48, 0xDA, 0x00 }, { 0x48, 0xFF, 0x00 },
	{ 0x6D, 0x00, 0x00 }, { 0x6D, 0x24, 0x00 }, { 0x6D, 0x48, 0x00 }, { 0x6D, 0x6D, 0x00 }, { 0x6D, 0x91, 0x00 }, { 0x6D, 0xB6, 0x00 }, { 0x6D, 0xDA, 0x00 }, { 0x6D, 0xFF, 0x00 },
	{ 0x91, 0x00, 0x00 }, { 0x91, 0x24, 0x00 }, { 0x91, 0x48, 0x00 }, { 0x91, 0x6D, 0x00 }, { 0x91, 0x91, 0x00 }, { 0x91, 0xB6, 0x00 }, { 0x91, 0xDA, 0x00 }, { 0x91, 0xFF, 0x00 },
	{ 0xB6, 0x00, 0x00 }, { 0xB6, 0x24, 0x00 }, { 0xB6, 0x48, 0x00 }, { 0xB6, 0x6D, 0x00 }, { 0xB6, 0x91, 0x00 }, { 0xB6, 0xB6, 0x00 }, { 0xB6, 0xDA, 0x00 }, { 0xB6, 0xFF, 0x00 },
	{ 0xDA, 0x00, 0x00 }, { 0xDA, 0x24, 0x00 }, { 0xDA, 0x48, 0x00 }, { 0xDA, 0x6D, 0x00 }, { 0xDA, 0x91, 0x00 }, { 0xDA, 0xB6, 0x00 }, { 0xDA, 0xDA, 0x00 }, { 0xDA, 0xFF, 0x00 },
	{ 0xFF, 0x00, 0x00 }, { 0xFF, 0x24, 0x00 }, { 0xFF, 0x48, 0x00 }, { 0xFF, 0x6D, 0x00 }, { 0xFF, 0x91, 0x00 }, { 0xFF, 0xB6, 0x00 }, { 0xFF, 0xDA, 0x00 }, { 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0x55 }, { 0x00, 0x24, 0x55 }, { 0x00, 0x48, 0x55 }, { 0x00, 0x6D, 0x55 }, { 0x00, 0x91, 0x55 }, { 0x00, 0xB6, 0x55 }, { 0x00, 0xDA, 0x55 }, { 0x00, 0xFF, 0x55 },
	{ 0x24, 0x00, 0x55 }, { 0x24, 0x24, 0x55 }, { 0x24, 0x48, 0x55 }, { 0x24, 0x6D, 0x55 }, { 0x24, 0x91, 0x55 }, { 0x24, 0xB6, 0x55 }, { 0x24, 0xDA, 0x55 }, { 0x24, 0xFF, 0x55 },
	{ 0x48, 0x00, 0x55 }, { 0x48, 0x24, 0x55 }, { 0x48, 0x48, 0x55 }, { 0x48, 0x6D, 0x55 }, { 0x48, 0x91, 0x55 }, { 0x48, 0xB6, 0x55 }, { 0x48, 0xDA, 0x55 }, { 0x48, 0xFF, 0x55 },
	{ 0x6D, 0x00, 0x55 }, { 0x6D, 0x24, 0x55 }, { 0x6D, 0x48, 0x55 }, { 0x6D, 0x6D, 0x55 }, { 0x6D, 0x91, 0x55 }, { 0x6D, 0xB6, 0x55 }, { 0x6D, 0xDA, 0x55 }, { 0x6D, 0xFF, 0x55 },
	{ 0x91, 0x00, 0x55 }, { 0x91, 0x24, 0x55 }, { 0x91, 0x48, 0x55 }, { 0x91, 0x6D, 0x55 }, { 0x91, 0x91, 0x55 }, { 0x91, 0xB6, 0x55 }, { 0x91, 0xDA, 0x55 }, { 0x91, 0xFF, 0x55 },
	{ 0xB6, 0x00, 0x55 }, { 0xB6, 0x24, 0x55 }, { 0xB6, 0x48, 0x55 }, { 0xB6, 0x6D, 0x55 }, { 0xB6, 0x91, 0x55 }, { 0xB6, 0xB6, 0x55 }, { 0xB6, 0xDA, 0x55 }, { 0xB6, 0xFF, 0x55 },
	{ 0xDA, 0x00, 0x55 }, { 0xDA, 0x24, 0x55 }, { 0xDA, 0x48, 0x55 }, { 0xDA, 0x6D, 0x55 }, { 0xDA, 0x91, 0x55 }, { 0xDA, 0xB6, 0x55 }, { 0xDA, 0xDA, 0x55 }, { 0xDA, 0xFF, 0x55 },
	{ 0xFF, 0x00, 0x55 }, { 0xFF, 0x24, 0x55 }, { 0xFF, 0x48, 0x55 }, { 0xFF, 0x6D, 0x55 }, { 0xFF, 0x91, 0x55 }, { 0xFF, 0xB6, 0x55 }, { 0xFF, 0xDA, 0x55 }, { 0xFF, 0xFF, 0x55 },
	{ 0x00, 0x00, 0xAA }, { 0x00, 0x24, 0xAA }, { 0x00, 0x48, 0xAA }, { 0x00, 0x6D, 0xAA }, { 0x00, 0x91, 0xAA }, { 0x00, 0xB6, 0xAA }, { 0x00, 0xDA, 0xAA }, { 0x00, 0xFF, 0xAA },
	{ 0x24, 0x00, 0xAA }, { 0x24, 0x24, 0xAA }, { 0x24, 0x48, 0xAA }, { 0x24, 0x6D, 0xAA }, { 0x24, 0x91, 0xAA }, { 0x24, 0xB6, 0xAA }, { 0x24, 0xDA, 0xAA }, { 0x24, 0xFF, 0xAA },
	{ 0x48, 0x00, 0xAA }, { 0x48, 0x24, 0xAA }, { 0x48, 0x48, 0xAA }, { 0x48, 0x6D, 0xAA }, { 0x48, 0x91, 0xAA }, { 0x48, 0xB6, 0xAA }, { 0x48, 0xDA, 0xAA }, { 0x48, 0xFF, 0xAA },
	{ 0x6D, 0x00, 0xAA }, { 0x6D, 0x24, 0xAA }, { 0x6D, 0x48, 0xAA }, { 0x6D, 0x6D, 0xAA }, { 0x6D, 0x91, 0xAA }, { 0x6D, 0xB6, 0xAA }, { 0x6D, 0xDA, 0xAA }, { 0x6D, 0xFF, 0xAA },
	{ 0x91, 0x00, 0xAA }, { 0x91, 0x24, 0xAA }, { 0x91, 0x48, 0xAA }, { 0x91, 0x6D, 0xAA }, { 0x91, 0x91, 0xAA }, { 0x91, 0xB6, 0xAA }, { 0x91, 0xDA, 0xAA }, { 0x91, 0xFF, 0xAA },
	{ 0xB6, 0x00, 0xAA }, { 0xB6, 0x24, 0xAA }, { 0xB6, 0x48, 0xAA }, { 0xB6, 0x6D, 0xAA }, { 0xB6, 0x91, 0xAA }, { 0xB6, 0xB6, 0xAA }, { 0xB6, 0xDA, 0xAA }, { 0xB6, 0xFF, 0xAA },
	{ 0xDA, 0x00, 0xAA }, { 0xDA, 0x24, 0xAA }, { 0xDA, 0x48, 0xAA }, { 0xDA, 0x6D, 0xAA }, { 0xDA, 0x91, 0xAA }, { 0xDA, 0xB6, 0xAA }, { 0xDA, 0xDA, 0xAA }, { 0xDA, 0xFF, 0xAA },
	{ 0xFF, 0x00, 0xAA }, { 0xFF, 0x24, 0xAA }, { 0xFF, 0x48, 0xAA }, { 0xFF, 0x6D, 0xAA }, { 0xFF, 0x91, 0xAA }, { 0xFF, 0xB6, 0xAA }, { 0xFF, 0xDA, 0xAA }, { 0xFF, 0xFF, 0xAA },
	{ 0x00, 0x00, 0xFF }, { 0x00, 0x24, 0xFF }, { 0x00, 0x48, 0xFF }, { 0x00, 0x6D, 0xFF }, { 0x00, 0x91, 0xFF }, { 0x00, 0xB6, 0xFF }, { 0x00, 0xDA, 0xFF }, { 0x00, 0xFF, 0xFF },
	{ 0x24, 0x00, 0xFF }, { 0x24, 0x24, 0xFF }, { 0x24, 0x48, 0xFF }, { 0x24, 0x6D, 0xFF }, { 0x24, 0x91, 0xFF }, { 0x24, 0xB6, 0xFF }, { 0x24, 0xDA, 0xFF }, { 0x24, 0xFF, 0xFF },
	{ 0x48, 0x00, 0xFF }, { 0x48, 0x24, 0xFF }, { 0x48, 0x48, 0xFF }, { 0x48, 0x6D, 0xFF }, { 0x48, 0x91, 0xFF }, { 0x48, 0xB6, 0xFF }, { 0x48, 0xDA, 0xFF }, { 0x48, 0xFF, 0xFF },
	{ 0x6D, 0x00, 0xFF }, { 0x6D, 0x24, 0xFF }, { 0x6D, 0x48, 0xFF }, { 0x6D, 0x6D, 0xFF }, { 0x6D, 0x91, 0xFF }, { 0x6D, 0xB6, 0xFF }, { 0x6D, 0xDA, 0xFF }, { 0x6D, 0xFF, 0xFF },
	{ 0x91, 0x00, 0xFF }, { 0x91, 0x24, 0xFF }, { 0x91, 0x48, 0xFF }, { 0x91, 0x6D, 0xFF }, { 0x91, 0x91, 0xFF }, { 0x91, 0xB6, 0xFF }, { 0x91, 0xDA, 0xFF }, { 0x91, 0xFF, 0xFF },
	{ 0xB6, 0x00, 0xFF }, { 0xB6, 0x24, 0xFF }, { 0xB6, 0x48, 0xFF }, { 0xB6, 0x6D, 0xFF }, { 0xB6, 0x91, 0xFF }, { 0xB6, 0xB6, 0xFF }, { 0xB6, 0xDA, 0xFF }, { 0xB6, 0xFF, 0xFF },
	{ 0xDA, 0x00, 0xFF }, { 0xDA, 0x24, 0xFF }, { 0xDA, 0x48, 0xFF }, { 0xDA, 0x6D, 0xFF }, { 0xDA, 0x91, 0xFF }, { 0xDA, 0xB6, 0xFF }, { 0xDA, 0xDA, 0xFF }, { 0xDA, 0xFF, 0xFF },
	{ 0xFF, 0x00, 0xFF }, { 0xFF, 0x24, 0xFF }, { 0xFF, 0x48, 0xFF }, { 0xFF, 0x6D, 0xFF }, { 0xFF, 0x91, 0xFF }, { 0xFF, 0xB6, 0xFF }, { 0xFF, 0xDA, 0xFF }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette256) == 256); }

// Generated fixed 128 colour palette.
namespace tQuantizeFixed { tColour3i Palette128[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0x24, 0x00 }, { 0x00, 0x48, 0x00 }, { 0x00, 0x6D, 0x00 }, { 0x00, 0x91, 0x00 }, { 0x00, 0xB6, 0x00 }, { 0x00, 0xDA, 0x00 }, { 0x00, 0xFF, 0x00 },
	{ 0x55, 0x00, 0x00 }, { 0x55, 0x24, 0x00 }, { 0x55, 0x48, 0x00 }, { 0x55, 0x6D, 0x00 }, { 0x55, 0x91, 0x00 }, { 0x55, 0xB6, 0x00 }, { 0x55, 0xDA, 0x00 }, { 0x55, 0xFF, 0x00 },
	{ 0xAA, 0x00, 0x00 }, { 0xAA, 0x24, 0x00 }, { 0xAA, 0x48, 0x00 }, { 0xAA, 0x6D, 0x00 }, { 0xAA, 0x91, 0x00 }, { 0xAA, 0xB6, 0x00 }, { 0xAA, 0xDA, 0x00 }, { 0xAA, 0xFF, 0x00 },
	{ 0xFF, 0x00, 0x00 }, { 0xFF, 0x24, 0x00 }, { 0xFF, 0x48, 0x00 }, { 0xFF, 0x6D, 0x00 }, { 0xFF, 0x91, 0x00 }, { 0xFF, 0xB6, 0x00 }, { 0xFF, 0xDA, 0x00 }, { 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0x55 }, { 0x00, 0x24, 0x55 }, { 0x00, 0x48, 0x55 }, { 0x00, 0x6D, 0x55 }, { 0x00, 0x91, 0x55 }, { 0x00, 0xB6, 0x55 }, { 0x00, 0xDA, 0x55 }, { 0x00, 0xFF, 0x55 },
	{ 0x55, 0x00, 0x55 }, { 0x55, 0x24, 0x55 }, { 0x55, 0x48, 0x55 }, { 0x55, 0x6D, 0x55 }, { 0x55, 0x91, 0x55 }, { 0x55, 0xB6, 0x55 }, { 0x55, 0xDA, 0x55 }, { 0x55, 0xFF, 0x55 },
	{ 0xAA, 0x00, 0x55 }, { 0xAA, 0x24, 0x55 }, { 0xAA, 0x48, 0x55 }, { 0xAA, 0x6D, 0x55 }, { 0xAA, 0x91, 0x55 }, { 0xAA, 0xB6, 0x55 }, { 0xAA, 0xDA, 0x55 }, { 0xAA, 0xFF, 0x55 },
	{ 0xFF, 0x00, 0x55 }, { 0xFF, 0x24, 0x55 }, { 0xFF, 0x48, 0x55 }, { 0xFF, 0x6D, 0x55 }, { 0xFF, 0x91, 0x55 }, { 0xFF, 0xB6, 0x55 }, { 0xFF, 0xDA, 0x55 }, { 0xFF, 0xFF, 0x55 },
	{ 0x00, 0x00, 0xAA }, { 0x00, 0x24, 0xAA }, { 0x00, 0x48, 0xAA }, { 0x00, 0x6D, 0xAA }, { 0x00, 0x91, 0xAA }, { 0x00, 0xB6, 0xAA }, { 0x00, 0xDA, 0xAA }, { 0x00, 0xFF, 0xAA },
	{ 0x55, 0x00, 0xAA }, { 0x55, 0x24, 0xAA }, { 0x55, 0x48, 0xAA }, { 0x55, 0x6D, 0xAA }, { 0x55, 0x91, 0xAA }, { 0x55, 0xB6, 0xAA }, { 0x55, 0xDA, 0xAA }, { 0x55, 0xFF, 0xAA },
	{ 0xAA, 0x00, 0xAA }, { 0xAA, 0x24, 0xAA }, { 0xAA, 0x48, 0xAA }, { 0xAA, 0x6D, 0xAA }, { 0xAA, 0x91, 0xAA }, { 0xAA, 0xB6, 0xAA }, { 0xAA, 0xDA, 0xAA }, { 0xAA, 0xFF, 0xAA },
	{ 0xFF, 0x00, 0xAA }, { 0xFF, 0x24, 0xAA }, { 0xFF, 0x48, 0xAA }, { 0xFF, 0x6D, 0xAA }, { 0xFF, 0x91, 0xAA }, { 0xFF, 0xB6, 0xAA }, { 0xFF, 0xDA, 0xAA }, { 0xFF, 0xFF, 0xAA },
	{ 0x00, 0x00, 0xFF }, { 0x00, 0x24, 0xFF }, { 0x00, 0x48, 0xFF }, { 0x00, 0x6D, 0xFF }, { 0x00, 0x91, 0xFF }, { 0x00, 0xB6, 0xFF }, { 0x00, 0xDA, 0xFF }, { 0x00, 0xFF, 0xFF },
	{ 0x55, 0x00, 0xFF }, { 0x55, 0x24, 0xFF }, { 0x55, 0x48, 0xFF }, { 0x55, 0x6D, 0xFF }, { 0x55, 0x91, 0xFF }, { 0x55, 0xB6, 0xFF }, { 0x55, 0xDA, 0xFF }, { 0x55, 0xFF, 0xFF },
	{ 0xAA, 0x00, 0xFF }, { 0xAA, 0x24, 0xFF }, { 0xAA, 0x48, 0xFF }, { 0xAA, 0x6D, 0xFF }, { 0xAA, 0x91, 0xFF }, { 0xAA, 0xB6, 0xFF }, { 0xAA, 0xDA, 0xFF }, { 0xAA, 0xFF, 0xFF },
	{ 0xFF, 0x00, 0xFF }, { 0xFF, 0x24, 0xFF }, { 0xFF, 0x48, 0xFF }, { 0xFF, 0x6D, 0xFF }, { 0xFF, 0x91, 0xFF }, { 0xFF, 0xB6, 0xFF }, { 0xFF, 0xDA, 0xFF }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette128) == 128); }

// Generated fixed 64 colour palette.
namespace tQuantizeFixed { tColour3i Palette64[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0x55, 0x00 }, { 0x00, 0xAA, 0x00 }, { 0x00, 0xFF, 0x00 }, { 0x55, 0x00, 0x00 }, { 0x55, 0x55, 0x00 }, { 0x55, 0xAA, 0x00 }, { 0x55, 0xFF, 0x00 },
	{ 0xAA, 0x00, 0x00 }, { 0xAA, 0x55, 0x00 }, { 0xAA, 0xAA, 0x00 }, { 0xAA, 0xFF, 0x00 }, { 0xFF, 0x00, 0x00 }, { 0xFF, 0x55, 0x00 }, { 0xFF, 0xAA, 0x00 }, { 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0x55 }, { 0x00, 0x55, 0x55 }, { 0x00, 0xAA, 0x55 }, { 0x00, 0xFF, 0x55 }, { 0x55, 0x00, 0x55 }, { 0x55, 0x55, 0x55 }, { 0x55, 0xAA, 0x55 }, { 0x55, 0xFF, 0x55 },
	{ 0xAA, 0x00, 0x55 }, { 0xAA, 0x55, 0x55 }, { 0xAA, 0xAA, 0x55 }, { 0xAA, 0xFF, 0x55 }, { 0xFF, 0x00, 0x55 }, { 0xFF, 0x55, 0x55 }, { 0xFF, 0xAA, 0x55 }, { 0xFF, 0xFF, 0x55 },
	{ 0x00, 0x00, 0xAA }, { 0x00, 0x55, 0xAA }, { 0x00, 0xAA, 0xAA }, { 0x00, 0xFF, 0xAA }, { 0x55, 0x00, 0xAA }, { 0x55, 0x55, 0xAA }, { 0x55, 0xAA, 0xAA }, { 0x55, 0xFF, 0xAA },
	{ 0xAA, 0x00, 0xAA }, { 0xAA, 0x55, 0xAA }, { 0xAA, 0xAA, 0xAA }, { 0xAA, 0xFF, 0xAA }, { 0xFF, 0x00, 0xAA }, { 0xFF, 0x55, 0xAA }, { 0xFF, 0xAA, 0xAA }, { 0xFF, 0xFF, 0xAA },
	{ 0x00, 0x00, 0xFF }, { 0x00, 0x55, 0xFF }, { 0x00, 0xAA, 0xFF }, { 0x00, 0xFF, 0xFF }, { 0x55, 0x00, 0xFF }, { 0x55, 0x55, 0xFF }, { 0x55, 0xAA, 0xFF }, { 0x55, 0xFF, 0xFF },
	{ 0xAA, 0x00, 0xFF }, { 0xAA, 0x55, 0xFF }, { 0xAA, 0xAA, 0xFF }, { 0xAA, 0xFF, 0xFF }, { 0xFF, 0x00, 0xFF }, { 0xFF, 0x55, 0xFF }, { 0xFF, 0xAA, 0xFF }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette64) == 64); }

// Generated fixed 32 colour palette.
namespace tQuantizeFixed { tColour3i Palette32[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0x55, 0x00 }, { 0x00, 0xAA, 0x00 }, { 0x00, 0xFF, 0x00 }, { 0x55, 0x00, 0x00 }, { 0x55, 0x55, 0x00 }, { 0x55, 0xAA, 0x00 }, { 0x55, 0xFF, 0x00 },
	{ 0xAA, 0x00, 0x00 }, { 0xAA, 0x55, 0x00 }, { 0xAA, 0xAA, 0x00 }, { 0xAA, 0xFF, 0x00 }, { 0xFF, 0x00, 0x00 }, { 0xFF, 0x55, 0x00 }, { 0xFF, 0xAA, 0x00 }, { 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0xFF }, { 0x00, 0x55, 0xFF }, { 0x00, 0xAA, 0xFF }, { 0x00, 0xFF, 0xFF }, { 0x55, 0x00, 0xFF }, { 0x55, 0x55, 0xFF }, { 0x55, 0xAA, 0xFF }, { 0x55, 0xFF, 0xFF },
	{ 0xAA, 0x00, 0xFF }, { 0xAA, 0x55, 0xFF }, { 0xAA, 0xAA, 0xFF }, { 0xAA, 0xFF, 0xFF }, { 0xFF, 0x00, 0xFF }, { 0xFF, 0x55, 0xFF }, { 0xFF, 0xAA, 0xFF }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette32) == 32); }

// Generated fixed 16 colour palette.
namespace tQuantizeFixed { tColour3i Palette16[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0x55, 0x00 }, { 0x00, 0xAA, 0x00 }, { 0x00, 0xFF, 0x00 }, { 0xFF, 0x00, 0x00 }, { 0xFF, 0x55, 0x00 }, { 0xFF, 0xAA, 0x00 }, { 0xFF, 0xFF, 0x00 },
	{ 0x00, 0x00, 0xFF }, { 0x00, 0x55, 0xFF }, { 0x00, 0xAA, 0xFF }, { 0x00, 0xFF, 0xFF }, { 0xFF, 0x00, 0xFF }, { 0xFF, 0x55, 0xFF }, { 0xFF, 0xAA, 0xFF }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette16) == 16); }

// Generated fixed 8 colour palette.
namespace tQuantizeFixed { tColour3i Palette8[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0xFF, 0x00 }, { 0xFF, 0x00, 0x00 }, { 0xFF, 0xFF, 0x00 }, { 0x00, 0x00, 0xFF }, { 0x00, 0xFF, 0xFF }, { 0xFF, 0x00, 0xFF }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette8) == 8); }

// Generated fixed 4 colour palette.
namespace tQuantizeFixed { tColour3i Palette4[] =
{
	{ 0x00, 0x00, 0x00 }, { 0x00, 0xFF, 0x00 }, { 0xFF, 0x00, 0x00 }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette4) == 4); }

// Generated fixed 2 colour palette.
namespace tQuantizeFixed { tColour3i Palette2[] =
{
	{ 0x00, 0x00, 0x00 }, { 0xFF, 0xFF, 0xFF }
}; tStaticAssert(tNumElements(tQuantizeFixed::Palette2) == 2); }


int tQuantizeFixed::FindIndexOfClosestColour_Redmean(const tColour3i* searchSpace, int searchSize, const tColour3i& colour)
{
	float closest = 1000.0f;
	int closestIndex = -1;

	for (int i = 0; i < searchSize; i++)
	{
		float diff = tMath::tColourDiffRedmean(colour, searchSpace[i]);
		if (diff < closest)
		{
			closest = diff;
			closestIndex = i;
		}
	}
	return closestIndex;
}


//
// The functions below make up the external interface.
//


bool tQuantizeFixed::QuantizeImage
(
	int numColours, int width, int height, const tPixel3* pixels, tColour3i* destPalette, uint8* destIndices,
	bool checkExact
)
{
	#ifdef QUANTIZE_GENERATE_FIXED_PALETTES
	static bool hasRun = false;
	if (!hasRun)
	{
		GenerateFixedPalettes("FixedPalettes.cpp");
		hasRun = true;
	}
	return false;
	#endif

	if ((numColours < 2) || (numColours > 256) || (width <= 0) || (height <= 0) || !pixels || !destPalette || !destIndices)
		return false;

	if (checkExact)
	{
		bool success = tQuantize::QuantizeImageExact(numColours, width, height, pixels, destPalette, destIndices);
		if (success)
			return true;
	}

	int tableSize = numColours;
	if (!tMath::tIsPower2(tableSize))
		tableSize = tMath::tNextHigherPower2(tableSize);
	tAssert(tMath::tIsPower2(tableSize) && (tableSize >= 2) && (tableSize <= 256));

	bool skipIndexArray[256];
	tStd::tMemset(skipIndexArray, 0, sizeof(skipIndexArray));

	// Skipping entries for non-power-of-two involves flipping from end to end (not including both ends). eg.
	//
	// 0 1 2 3 4 5 6 7					: Total 8.  Worst case 5. Reduce by 3.
	//   ^
	//             ^
	//       ^
	// 0 1 2 3 4 5 6 7 0 1 2 3 4 5 6 7	: Total 16. Worst case 9. Reduce by 7.
	//   ^
	//                             ^
	//       ^
	//                         ^
	//           ^
	//                     ^
	//               ^
	int numSkipped = 0;
	bool flipFlop = false;
	int skipIndexLow = 1;
	int skipIndexHigh = tableSize - 2;
	while (tableSize - numColours - numSkipped)
	{
		skipIndexArray[!flipFlop ? skipIndexLow : skipIndexHigh] = true;
		if (!flipFlop) 	skipIndexLow += 2;
		else			skipIndexHigh -= 2;
		flipFlop = !flipFlop;
		numSkipped++;
	}

	tColour3i* srcPalette = nullptr;
	switch (tableSize)
	{
		case 2:		srcPalette = Palette2;		break;
		case 4:		srcPalette = Palette4;		break;
		case 8:		srcPalette = Palette8;		break;
		case 16:	srcPalette = Palette16;		break;
		case 32:	srcPalette = Palette32;		break;
		case 64:	srcPalette = Palette64;		break;
		case 128:	srcPalette = Palette128;	break;
		case 256:	srcPalette = Palette256;	break;
	}

	// Populate the dest palette, skipping as necessary.
	int destIndex = 0;
	for (int srcIndex = 0; srcIndex < tableSize; srcIndex++)
	{
		if (skipIndexArray[srcIndex])
			continue;
		destPalette[destIndex++] = srcPalette[srcIndex];
	}
	tAssert(destIndex == numColours);

	// Exhaustive redmean search for each pixel colour.
	for (int y = 0; y < height; y++)
	{
		for (int x = 0; x < width; x++)
		{
			const tPixel3& pixel = pixels[x + y*width];
			destIndices[x + y*width] = FindIndexOfClosestColour_Redmean(destPalette, numColours, pixel);
		}
	}

	return true;
}


bool tQuantizeFixed::QuantizeImage
(
	int numColours, int width, int height, const tPixel* pixels, tColour3i* destPalette, uint8* destIndices,
	bool checkExact
)
{
	if ((numColours < 2) || (numColours > 256) || (width <= 0) || (height <= 0) || !pixels || !destPalette || !destIndices)
		return false;

	tPixel3* pixels3 = new tPixel3[width*height];
	for (int p = 0; p < width*height; p++)
		pixels3[p].Set( pixels[p].R, pixels[p].G, pixels[p].B );

	bool success = QuantizeImage(numColours, width, height, pixels3, destPalette, destIndices, checkExact);
	delete[] pixels3;
	return success;
}


}
