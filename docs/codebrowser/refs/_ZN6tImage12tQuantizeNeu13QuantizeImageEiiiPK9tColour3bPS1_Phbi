<dec f='Modules/Image/Inc/Image/tQuantize.h' l='136' type='bool tImage::tQuantizeNeu::QuantizeImage(int numColours, int width, int height, const tPixel3b * pixels, tColour3b * destPalette, uint8 * destIndices, bool checkExact = true, int sampleFactor = 1)'/>
<doc f='Modules/Image/Inc/Image/tQuantize.h' l='125'>// With a sampling factor of 1 the entire image is used in the learning phase. With a factor of 10, a
	// pseudo-random subset of 1/10 of the pixels are used in the learning phase. sampleFactor must be in [1, 30].
	// Bigger values are faster but lower quality.
	//
	// If checkExact is true it will inspect all supplied pixels in case there are &lt;= numColours of them. If that is
	// true then the image is exactly representable given the palette size and the quantize is not needed. The operation
	// to gather unique pixel colours is a little slow, so you are given the ability to turn this off.
	//
	// destPalette should have space for numColours colours,
	// destIndices should have space for width*height indices.
	// The second variant is same as first but accepts RGBA pixels ignoring alpha.</doc>
<use f='Modules/Image/Src/tPaletteImage.cpp' l='148' u='c' c='_ZN6tImage13tPaletteImage3SetENS_12tPixelFormatEiiPK9tColour3bNS_9tQuantize6MethodE'/>
<def f='Modules/Image/Src/tQuantizeNeu.cpp' l='537' ll='579' type='bool tImage::tQuantizeNeu::QuantizeImage(int numColours, int width, int height, const tPixel3b * pixels, tColour3b * destPalette, uint8 * destIndices, bool checkExact = true, int sampleFactor = 1)'/>
<use f='Modules/Image/Src/tQuantizeNeu.cpp' l='595' u='c' c='_ZN6tImage12tQuantizeNeu13QuantizeImageEiiiPK9tColour4bP9tColour3bPhbi'/>
<doc f='Modules/Image/Src/tQuantizeNeu.cpp' l='532'>//
// The functions below make up the external interface.
//</doc>
