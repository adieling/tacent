<dec f='Modules/Image/Inc/Image/tQuantize.h' l='108' type='bool tImage::tQuantizeSpatial::QuantizeImage(int numColours, int width, int height, const tPixel3b * pixels, tColour3b * destPalette, uint8 * destIndices, bool checkExact = true, double ditherLevel = 0., int filterSize = 3)'/>
<doc f='Modules/Image/Inc/Image/tQuantize.h' l='99'>// If ditherLevel is 0.0 uses ComputeBaseDither, otherwise ditherLevel must be &gt; 0.0. filterSize must be 1, 3, or 5.
	//
	// If checkExact is true it will inspect all supplied pixels in case there are &lt;= numColours of them. If that is
	// true then the image is exactly representable given the palette size and the quantize is not needed. The operation
	// to gather unique pixel colours is a little slow, so you are given the ability to turn this off.
	//
	// destPalette should have space for numColours colours,
	// destIndices should have space for width*height indices.
	// The second variant is same as first but accepts RGBA pixels ignoring alpha.</doc>
<use f='Modules/Image/Src/tPaletteImage.cpp' l='144' u='c' c='_ZN6tImage13tPaletteImage3SetENS_12tPixelFormatEiiPK9tColour3bNS_9tQuantize6MethodE'/>
<def f='Modules/Image/Src/tQuantizeSpatial.cpp' l='838' ll='937' type='bool tImage::tQuantizeSpatial::QuantizeImage(int numColours, int width, int height, const tPixel3b * pixels, tColour3b * destPalette, uint8 * destIndices, bool checkExact = true, double ditherLevel = 0., int filterSize = 3)'/>
<use f='Modules/Image/Src/tQuantizeSpatial.cpp' l='953' u='c' c='_ZN6tImage16tQuantizeSpatial13QuantizeImageEiiiPK9tColour4bP9tColour3bPhbdi'/>
